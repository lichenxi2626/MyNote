# 	**java**

***

## 序章 编程入门

### 0.1 概述



### 0.2 计算机硬件介绍

冯诺依曼体系结构

![1581647401650](java上.assets\1581647401650.png)

#### 0.2.1 中央处理器（CPU）

包括控制单元和算数/逻辑单元。

1Hz相当于每秒1个脉冲

GHz（千兆赫兹）

IT定律-计算机行业发展规律

- 摩尔定律(Moore’s Law)

- 安迪-比尔定律(Andy and Bill’s Law)

- 反摩尔定律(Reverse Moore’s Law)


#### 0.2.2 存储设备

光驱、硬盘、U盘

#### 0.2.3 内存（RAM）

##### 比特（bit）和字节（byte）

比特：一个0或者一个1存储为一个比特（bit），是计算机中最小的存储单位。

字节：计算机中最基本的存储单元，每个字节由8个比特组成。



### 0.3 计算机发展史上的鼻祖

- 阿兰图灵（Alan Turing）：计算机科学和人工智能之父。
- 冯诺依曼（John von Neumann）：计算机之父和博弈论之父。冯诺依曼理论的要点：数字计算机的数制采用二进制；计算机应该按照程序顺序执行。




### 0.4 操作系统（Operating System）

![1581649287544](java上.assets\1581649287544.png)

操作系统是运行在计算机上的最重要的程序，它可以管理和控制计算机的活动。



### 0.5 万维网

- 万维网www (world Wide Web)

- 超文本传输协议http (Hypertext Transfer Protocol)



## 第一章 java语言概述

### 1.1 软件开发介绍

软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。

人机交互方式：图形化界面和命令行方式。

#### 1.1.1 常用的dos指令

| 指令 | 功能                           |
| :--- | ------------------------------ |
| dir  | 列出当前目录下的文件以及文件夹 |
| md   | 创建目录                       |
| rd   | 删除目录                       |
| cd   | 进入指定目录                   |
| cd.. | 退回到上一级目录               |
| cd/  | 退回到根目录                   |
| del  | 删除文件/删除目录下的全部文件  |
| exit | 退出dos命令行                  |

#### 1.1.2 常用快捷键

| 按键              | 功能             |
| ----------------- | ---------------- |
| ←   →             | 移动光标         |
| ↑   ↓             | 调阅历史操作命令 |
| Delete或Backspace | 删除字符         |



### 1.2 计算机编程语言介绍

计算机语言：人与计算机交流的方式。

如：C，C++，Java，PHP，Kotlin，Python，Scala等。

语言 = 语法 + 逻辑

- 第一代语言（机器语言）：机器语言，指令以二进制代码形式存在。

- 第二代语言（汇编语言）：汇编语言，使用助记符表示一条机器指令。

- 第三代语言（高级语言）
  - C、Pascal、Fortran 面向过程的语言；
  - C++面向过程/面向对象；
  - Java跨平台的纯面向对象的语言；
  - .NET跨语言平台；
  - Python、Scala...




### 1.3 Java语言概述

Java是SUN（斯坦福大学网络公司）1995年推出的一门高级编程语言。

2009年被Oracle收购。

- #### Java技术体系平台
  1. Java SE(Java Standard Edition)标准版
  2. Java EE(Java Enterprise Edition)企业版 主要应用场景
  3. Java ME(Java Micro Edition)小型版
  4. Java Card

- Java语言应用方向

  - 企业级应用

  - Android平台应用

  - 大数据平台开发

Java语言的诞生

- java之父James Gosling
- Java是一个纯粹的面向对象的程序设计语言，舍弃了C语言中容易引起错误的指针，增加了垃圾回收器功能。




### 1.4 Java语言运行机制及运行过程

- #### Java语言的特点
  - 一、面向对象
    - 两个基本概念：类、对象

    - 三大特性：封装性、继承性、多态性

  - 
    健壮性
  - 跨平台性

- #### Java的两种核心机制
  - Java虚拟机（JVM）
  - 垃圾收集器（Garbage Collection）



### 1.5 Java语言环境搭建

JDK（Java Development Kit）Java开发工具包，包含JRE

JRE（Java Runtime Environment） Java运行环境，包含JVM

JVM（Java Virtal Machine）Java虚拟机

![1581667883215](java上.assets\1581667883215.png)

配置环境变量Path

1. 此电脑→属性→高级系统设置→环境变量
2. 添加Java安装根目录下的bin文件夹路径




### 1.6 开发体验-HelloWorld

1. javac.exe(编译)  .java 源文件

2. java.exe(运行)  .class 字节码文件


```java
class HelloWorld
    public static void main(String[] args){
    	System.out.println("HelloWorld！")
}
```



### 1.7 常见问题及解决方法

- 在一个java源文件中，可以声明一个或多个类，编译后，也会对应生成多个字节码文件。

- 在一个源文件中，最多只能有一个类生命为public，且声明为public的类名必须与源文件名一致。

- 在一个源文件中，不能声明多个同名的类（Java严格区分大小写）。

- 程序中的大括号｛｝是成对出现的，声明类、方法时，会使用一对｛｝。

- main｛｝是程序的入口，格式是固定的。


```java
//方式一
public static void main(String[] args){}
//方式二
public static void main(String args[]){}
//参数名args可替换
```

```java
System.out.println();
//先输出语句，后换行
System.out.print();
//输出语句，不换行
```

每一行执行语句都应该以 " ; " 结尾。

"\n" 换行符	"\t"制表符



### 1.8 注释（Comment）

```java
//单行注释

/*
多行注释
*/

/**
文档注释
@author 指定java程序的作者
@version 指定源文件的版本
*/
```

单行、多行注释不会被编译，用于对程序进行解释说明或用于调试程序。

注释不能嵌套使用。



### 1.9 Java API文档

API（Application Programming Interface 应用程序编程接口）是Java提供的基本编程接口



## 第二章 Java基本语法

### 2.1 关键字与保留字

关键字：被Java语言赋予了特殊含义，用作专门用途的字符串（单词）。

特点：**关键字中所有字母都为小写**。

| 关键字类型                                   | 例                                                           |
| -------------------------------------------- | ------------------------------------------------------------ |
| 用于定义数据类型的关键字                     | class  interface  enum  byte  short  int  long  float  double  char  boolean  void |
| 用于定义流程控制的关键字                     | if  else  switch  case  default  while  do  for  break  continue  return |
| 用于定义访问权限修饰符的关键字               | private  public  protected                                   |
| 用于定义函数、类、变量修饰符的关键字         | abstract  final  static  synchronized                        |
| 用于定义类与类之间关系的关键字               | extends  implements                                          |
| 用于定义建立实例及引用实例，判断实例的关键字 | new  this  super  instanceof                                 |
| 用于异常处理的关键字                         | try  catch  finally  throw  throws                           |
| 用于包的关键字                               |                                                              |
| 其他修饰符关键字                             |                                                              |
| 用于定义数据类型值的字面值（非关键字）       |                                                              |

保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用，在命名时应避免使用。



### 2.2 标识符（Identifier）

标识符：Java对各种变量、方法和类等要素命名时使用的字符序列成为标识符。（凡是可以自己命名的都是标识符）

#### 2.2.1 合法标识符规则

​	**1、由26个英文字母大小写，0-9，_或$组成；**

​	**2、不可以以数字作为开头；**

​	**3、不可以使用关键字和保留字，但能包含关键字和保留字；**

​	**4、Java中严格区分大小写，长度无限制；**

​	**5、标识符不能包含空格。**

#### 2.2.2 标识符命名规范

​	1、包名：所有字母都小写；

​	2、类名、接口名：多单词使用时，所有单词首字母大写；

​	3、变量名、方法名：多单词使用时，首单词首字母小写，后续单词首字母大写；

​	4、常量名：所有字母都大写，多单词使用时，每个单词用下划线"_"连接。



### 2.3 变量

概念：变量是内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。变量是程序中最基本的存储单元。包含**变量类型、变量名和存储的值**。

作用：用于在内存中保存数据。

注意：

​	1、**Java中每个变量必须先声明，后使用**；

​	2、使用变量名来访问这块区域的数据；

​	3、变量的作用域为其定义所在的一对｛｝内；

​	4、变量只有在其作用域内才有效；

​	5、同一个作用域内，不能定义重名的变量。

```java
//变量的声明 <数据类型> <变量名>
//变量的赋值 <变量名> = <值>
//方式一
int myNumber = 1001;
//方式二
int myNumber;
myNumber = 1001;
```

#### 2.3.1 Java中变量的类型

1、按数据类型分类

- 基本数据类型（8种）：

  ​	整形：byte、short、int、long

  ​	浮点型：float、double

  ​	字符型：char

  ​	布尔型：boolean

- 引用数据类型：

  ​	类（class）

  ​	接口（interface）

  ​	数组（array）

2、按声明的位置分类

- 成员变量：

  ​	实例变量（不以static修饰）

  ​	类变量（以static修饰）

- 局部变量：

  ​	形参（方法、构造器中定义的变量）

  ​	方法局部变量（在方法内定义）

  ​	代码块局部数量（在代码块内定义）




#### 2.3.2 整型

| 类型  | 占用存储空间 | 数值范围                                  |
| ----- | ------------ | ----------------------------------------- |
| byte  | 1字节 = 8bit | [ -128 , 127 ]                            |
| short | 2字节        | [ -2^15 , 2^15-1 ] 即 [ - 32768 , 32767 ] |
| int   | 4字节        | [ -2^31 , 2^31-1 ] 约 21 亿               |
| long  | 8字节        | [ -2^63 , 2^63-1 ]                        |

- Java的整型常量默认为int型。

- long型常量声明赋值时，需加L或l后缀。


```java
byte i1 = 100;
short i2 = 10000;
int i3 = 100000000;
long i4 = 1000000000000L;
long i5 = 100; //可编译，等价于将int型的100赋值给long型
```



#### 2.3.3 浮点型

| 类型   | 占用存储空间 | 数值范围                   |
| ------ | ------------ | -------------------------- |
| float  | 4字节        | [ -3.403E38 , 3.403E38 ]   |
| double | 8字节        | [ -1.798E308 , 1.798E308 ] |

- Java的浮点型常量默认是double型。

- float型常量声明赋值时，需加F或f后缀。

- float精度为小数点后7位，double精度为float的两倍。


```java
float f1 = 12.34F
double d1 = 12.3456789;
```



#### 2.3.4 字符型

char：表示一个字符，使用一对 '' 表示。

char可以赋值为' '（一个空格），但不能赋值为''（空）。

```java
char c1 = 'a';	//单个字符
char c2 = '\t';	//转义字符
char c3 = '\u4e2d'	//unicode编码
```

char型常量可以参与运算，因为有对应的Unicode编码。

ASCII码：一共规定了128个字符的编码。

Unicode码：规定了世界上所有的符号，每一个符号都赋予了一个独一无二的编码，因此没有乱码问题。

UTF-8：使用最广的一种Unicode编码的实现方式，



#### 2.3.4 布尔型

boolean：只有两个值，true和false。

```java
boolean bo1 = true;
boolean bo2 = false;
```



#### 2.3.5 基本数据类型变量的运算规则

- 自动类型转换
  - 容量小的数据类型与容量大的数据类型的变量运算时，结果的数据类型为容量大的数据类型。

  - 数据类型容量由小到大排序为：

    byte/short/char < int < long < float < double

  - byte、short、char相互运算时，结果的数据类型为int。

  - boolean型不能与其它数据类型计算。

- 强制类型转换
  - 容量大的数据类型转为容量小的数据类型时，使用强制转换符"()"进行强制转换，但可能造成数值精度降低或溢出。
  - boolean类型不可转化为其他的数据类型。

```java
int i1 = 123；
byte b1 = (byte)i1; //将int型数据强转为byte
```



#### 2.3.6  字符串类型String

1. String不是基本数据类型，是引用数据类型，表示字符串类型的变量，使用一对""表示。

2. String与8种基本数据类型变量间的运算，只能使用连接符号"+"，且运算结果类型仍为String。

3. String与基本数据类型无法互相强制转换。




#### 2.3.7 进制

- 二进制：0、1，以0b或0B开头；

- 八进制：0~7，以0开头；

- 十进制：0~9；

- 十六进制：0~9、A~F，以0x或0X开头。




二进制的原码、反码与补码：

![1581757370182](java上.assets\1581757370182.png)



### 2.4 运算符

#### 2.4.1 算术运算符

| 运算符 | 作用说明                   | 举例                             | 结果                         |
| ------ | -------------------------- | -------------------------------- | ---------------------------- |
| +      | 正号                       | +3                               | 3                            |
| -      | 负号                       | b = 4;-b                         | -4                           |
| +      | 加                         | 5 + 5                            | 10                           |
| -      | 减                         | 6 - 4                            | 2                            |
| *      | 乘                         | 3 * 4                            | 12                           |
| /      | 除                         | 13 / 5                           | 2                            |
| %      | 取模（取余）               | 13 / 5                           | 3                            |
| ++     | 自增<br />//不改变数据类型 | a = 2;b = ++a<br />a = 2;b = a++ | a = 3;b = 3<br />a = 3; b =2 |
| --     | 自减<br />//不改变数据类型 | a = 2;b = --a<br />a = 2;b = a-- | a = 1;b = 1<br />a = 1; b =2 |
| +      | 连接                       | "Ni" + "Hao"                     | "NiHao"                      |

取模运算中，运算结果的符号取决于被模数的符号。

``` java
int i1 = -13;
int i2 = -5;
System.out.println(i1 % i2);
//输出结果为-3
```

#### 2.4.2 赋值运算符

| 运算符 | 作用说明 | 举例              | 结果 |
| ------ | -------- | ----------------- | ---- |
| =      | 赋值     | int i = 5         | 5    |
| +=     | 自加     | int i = 5; i +=1  | 6    |
| -=     | 自减     | int i = 5; i -=1  | 4    |
| *=     | 自乘     | int i = 5; i *= 2 | 10   |
| /=     | 自除     | int i = 5; i /= 2 | 2    |
| %=     | 自取模   | int i = 5; i %= 2 | 1    |

赋值运算均不改变原有数据类型。

#### 2.4.3 比较运算符

| 运算符     | 作用说明       | 举例                       | 结果  |
| ---------- | -------------- | -------------------------- | ----- |
| ==         | 等于           | 4==3                       | false |
| !=         | 不等于         | 4!=3                       | true  |
| >          | 大于           | 4>3                        | true  |
| <          | 小于           | 4<3                        | false |
| >=         | 大于等于       | 4>=3                       | true  |
| <=         | 小于等于       | 4<=3                       | false |
| instanceof | 是否为类的对象 | "hello" intstanceof String | true  |

比较运算的返回结果数据类型均为boolean。

#### 2.4.4 逻辑运算符

| a     | b     | a&b   | a&&b  | a\|b  | a\|\|b | !a    | a^b   |
| ----- | ----- | ----- | ----- | ----- | ------ | ----- | ----- |
| true  | true  | true  | true  | true  | true   | false | false |
| true  | false | false | false | true  | true   | false | true  |
| false | true  | false | false | true  | true   | true  | true  |
| false | false | false | false | false | false  | true  | false |

- &&为短路与，若a为false，b不执行，直接输出结果false；

- ||为短路或，若a为true，b不执行，直接输出结果true。

#### 2.4.5 位运算符

| 运算符 | 作用说明                       | 举例  | 结果 |
| ------ | ------------------------------ | ----- | ---- |
| <<     | 左移，空位补0                  | 3<<2  | 12   |
| >>     | 右移，正数空位补0，负数空位补1 | 3>>1  | 1    |
| >>>    | 无符号右移，空位补1            | 3>>>1 | 1    |
| &      | 与，有0则0，全1则1             | 6&3   | 2    |
| \|     | 或，有1则1，全0则0             | 6\|3  | 7    |
| ^      | 异或，相同为0，不同为1         | 6^3   | 5    |
| ~      | 取反，1取0，0取1               | 6     | -7   |

位运算是直接对整数的二进制进行的运算。

#### 2.4.6 三元运算符

```java
//语法格式
(条件表达式)?表达式1:表达式2；
//例
int m = 12;
int n = 5;
int max = (m > n)? m : n;
```

- 根据条件表达式结果取值，若为true，则取表达式1，**且表达式2不执行**，若为false，则取表达式2，**且表达式1不执行**。
- 要求表达式1与表达式2的数据类型一致。
- 三元运算符中的类型提升：
  - 若表达式1和表达式2具有相同的类型，那么整个三元运算符的结果就是这个类型；
  - 若表达式1为byte/short/char，表达式2为**int型的常量表达式**，且表达式2的值是可以用byte/short/char表示的，那么整个条件运算符结果的类型就是byte/short/char；
  - 除以上情况外，**若表达式1和表达式2的类型不同，将进行自动的类型提升，运算结果为提升后的类型**。




### 2.5 程序流程控制

#### 2.5.1 顺序结构

#### 2.5.2 if-else结构

```java
//语法
if (条件表达式1) {
	执行代码块1;
} else if (条件表达式2) {
    执行代码块2;
} else {
	执行代码块3;
}
```

使用说明：

​	1、条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量。

​	2、语句块只有一条执行语句时，一对{}可以省略，但建议保留。

​	3、if-else语句结构，根据需要可以嵌套使用。

​	4、当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略。

​	5、当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓。

​	6、当多个条件是“包含”关系时，“小上大下 / 子上父下”。



##### Scanner的使用

```java
//调用Scanner类
import java.util.Scanner;
//声明一个Scanner类的对象
Scanner scan = new Scanner(System.in);
//声明变量接收
int i = scan.nextInt();
```



##### random的使用

```java
//生成[0.1,1.0)中的一个随机数
double v1 = Math.random();
//生成一个[10,100)中的随机整数
int v2 = (int)(Math.random() * 90 + 10);
//生成一个[a,b]中的随机整数
int v3 = (int)(Math.random() * (b - a + 1) + a);
```



##### sqrt的使用

```java
//开方
int i = 4;
double d = Math.sqrt(i);
```



#### 2.5.3 switch-case结构

```java
switch(表达式){
    case 常量1：
        执行语句1；
        //break;
	case 常量2:
        执行语句2;
        //break;
	case 常量3:
		执行语句3;
		//break；
	default:
		执行语句n;
		//break;
}
```

- 1、switch(表达式)中表达式的值必须是下述几种类型之一：**byte，short，char，int，枚举（jdk5.0），String（jdk7.0）**；

- 2、case子句中的值必须是**常量**，不能是变量名或不确定的表达式值；
- 3、同一个switch语句，所有case子句中的常量值互不相同；

- 4、break语句用来在执行完一个case分支后使程序跳出switch语句块，如果没有break，程序会顺序执行到switch结尾；

- 5、default子句是**可选的**，位置也是灵活的，default会匹配所有类型数据，若没有break退出，会执行后续所有分支。



#### 2.5.4 for循环

循环语句的四个组成部分

- 初始化部分；

- 循环条件部分；
- 循环体部分；

- 迭代部分。

```java
//for循环结构
for (初始化部分;循环条件部分;迭代部分){
    循环体部分;
}

//遍历1-100
for(int i = 1; i <= 100; i++){
    System.out,println(i);
}
```

退出循环的两种方式：

- 通过循环条件结果为false退出循环；
- 通过循环体中加入break子句退出循环。



#### 2.5.5 while循环

```java
//while循环结构
初始化部分；
while(循环条件部分){
    循环体部分;
    迭代部分;
}

//遍历1-100
int i = 1;
while(i <= 100){
    System.out.prinln(i);
    i++;
}
```

- while循环中，循环条件部分不能为空。



#### 2.5.6 do-while循环

```java
//do-while循环结构
初始化部分;
do{
    循环体部分;
    迭代条件;
} while (循环条件部分);

//遍历1-100
int i = 1;
do{
    System.out.println(i);
    i++;
}while(i <= 100);
```

do-while循环一定能至少执行一次。



#### 2.5.7 break和continue的使用

| 关键字   | 适用范围                      | 循环结构中的作用       | 相同点                     |
| -------- | ----------------------------- | ---------------------- | -------------------------- |
| break    | 循环结构<br />switch-case结构 | 结束（或跳出）当前循环 | 在关键字后不能声明执行语句 |
| continue | 循环结构                      | 结束（或跳出）当次循环 | 在关键字后不能声明执行语句 |

```java
//break结束外层循环,continue同理
label:for (int i = 1; i <= 10; i++){
	for (int j = 1; j <= 10; j++){
		if (j % 3 == 0){
			break label;
		}
	} 
}
```

- continue在do-while循环中，作用为结束当次循环的循环体内容，并从**循环条件部分**开始下次循环。



## 第三章 数组

### 3.1 数组的概述

- 数组(Array)，是多个**相同类型数据**按**一定顺序排列**的集合，并使用**一个名字命名**，并通过**编号**的方式对这些数据进行统一管理。
- 数组本身是**引用数据类型**，而数组中的元素可以是**任何数据类型**，包括基本数据类型和引用数据类型。
- 创建数组对象会在内存中开辟一整块的**连续的空间**，而数组名中引用的是这块连续空间的**首地址**。
- 数组的**长度一旦确定，就不能更改**。
- 我们可以直接通过下标（或索引）的方式调用指定位置的元素，速度很快。
- 数组的分类：
  - 按照维度：一位数组、二维数组、三维数组...
  - 按照元素的数据类型分：基本数据类型元素的数组，引用数据类型元素的数组（即对象数组）。

### 3.2 一维数组的使用

```java
//一维数组的声明方式（两种）
type var[];
type[] var;
//示例：
int a[];
int[] a;
double b[];
String[] c;
```

- 声明数组语法**仅有两种**，即[]跟在数据类型后或跟在数组名后，其余方式均非法。

- Java中声明数组时不能指定其长度，例如：int a[5]。

#### 3.2.1 一维数组的初始化

- 动态初始化：定义数组时，为数组元素分配空间与给数组元素赋值的操作分开进行（声明数组与分配空间在不在一行语句均可，但赋值操作必须单独执行）；

```java
//例1，声明与分配空间同时进行
int[] arr = new int[3];
arr[0] = 3;
arr[1] = 6;
arr[2] = 9;
//例2，声明与分配空间分布进行
String names[];
names = new String[3];
names[0] = "邓稼先";
names[1] = "钱学森";
names[2] = "袁隆平";
```

- 静态初始化：定义数组的同时，为数组元素分配空间并赋值（必须在一行语句内完成分配空间并赋值的操作）。

```java
//例1
int[] arr = new int[]{3,4,5};

int[] arr;
arr = new int[]{3,4,5};

//例2,类型推断
int arr[] = {3,4,5};
```

- 定义并用运算符new为之分配空间后，才可以引用数组中的每个元素；

- 数组元素的引用方式：数组名[数组元素下标]

  - 数组元素下标可以是**整形常量**或**整形表达式**
  - 数组元素**下标从0开始**，长度为n的数组合法下标取值范围为[0,n-1]

- 每个数组都有一个属性length指名它的长度，例如：arr.length即为数组arr的长度（元素个数）。

- 数组是引用数据类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中每个元素也被按照成员变量同样的方式被隐式初始化。

  - 基本数据类型数组在显式赋值之前，Java会自动给他们赋默认值。

  | 数组元素类型 | 元素默认初始值                     |
  | ------------ | ---------------------------------- |
  | byte         | 0                                  |
  | short        | 0                                  |
  | int          | 0                                  |
  | long         | 0L  (sysout结果为"0")              |
  | float        | 0.0F  (sysout结果为"0.0")          |
  | double       | 0.0                                |
  | char         | 0或写为'\u0000'  (sysout结果为" ") |
  | boolean      | false                              |
  | 引用数据类型 | null                               |

  

### 3.3 多维数组的使用

- 对于二维数组，可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。实际上，**从数组底层的运行机制来看，并没有多维数组**。

#### 3.3.1 二维数组的初始化

- 动态初始化

```java
//声明格式（3种）
int[][] arr;
int[] arr[];
int arr[][];

//初始化格式1
int[][] arr = new int[3][2];

//初始化格式2
int[][] arr = new int[3][];
arr[0] = new int[2];
arr[1] = new int[3];
arr[2] = new int[4];
```

- 静态初始化

```java
//声明+初始化格式
int[][] arr = new int[][]{{1,2,3},{4,5},{6,7,8,9}};
```



- 只有明确给出数组长度（即数组中元素个数）时，对象才会在内存中开辟对应的空间，该数组才有地址，否则该数组的默认初始化值为null（即引用数据类型的初始化值）。
- 外层数组元素默认存储的是数组的类型和地址值，内层默认初始化值和一维数组一致。
- char[]在内存中存储的也是地址值，只是在System.out.println()；方法中对对象为char[]类型的数据进行了改写，导致结果为char[]中所有元素的连续输出。



- **数组在内存中生成的流程：**
  
  1. **声明数组名和类型 **
  2. **为该数组分配空间（有几个元素）、分配地址，根据数据类型初始化该数组中元素的默认数值**
  3. **为数组元素赋值**
  
  

### 3.4 数组中涉及到的常见算法

#### 3.4.1 数组元素的赋值

```java
//输出10行杨辉三角
public class YangHui {
	public static void main(String[] args) {
		//声明并初始化二维数组
		int[][] yangHui = new int[10][];
		
		for (int i = 0; i < yangHui.length; i++) {
			//循环初始化每行对应数组，元素个数逐行+1
            yangHui[i] = new int[i + 1];
			//为每个数组元素赋值
			for (int j = 0; j < yangHui[i].length; j++) {
				if (j == 0) {
					yangHui[i][j] = 1;
					System.out.print(yangHui[i][j] + "\t");
				}else if(j == i) {
					yangHui[i][j] = 1;
					System.out.print(yangHui[i][j] + "\t");
				}else {
					yangHui[i][j] = yangHui[i - 1][j - 1] + yangHui[i - 1][j];
					System.out.print(yangHui[i][j] + "\t");
				}
			}		
			System.out.println();		
		}
	}
}

/*运行结果
1	
1	1	
1	2	1	
1	3	3	1	
1	4	6	4	1	
1	5	10	10	5	1	
1	6	15	20	15	6	1	
1	7	21	35	35	21	7	1	
1	8	28	56	70	56	28	8	1	
1	9	36	84	126	126	84	36	9	1	
*/
```

```java
//输出回形数
import java.util.Scanner;

public class Zigzag {
	public static void main(String[] args) {
		
		Scanner scan = new Scanner(System.in);
		System.out.print("请输入矩阵宽度:");
		int width = scan.nextInt();
		//初始化矩阵
		int[][] zigzag = new int[width][width];
		int number = 1;//回形数数字
		
        //外层循环 循环次数为(zigzag.length+1)/2
		for (int i = 0; i < (zigzag.length + 1) / 2 ; i++) {
            
            //当矩阵宽度为奇数时，赋值到矩阵中心时只有一个元素，直接对该元素赋值并退出循环，避免重复赋值
			if (i == (zigzag.length + 1) / 2 - 1 && width % 2 == 1) {
				zigzag[width/2][width/2] = number++;
				break;
			}
			
            //每一层循环又分为四个方向上的循环赋值
			for (int j = 0; j < zigzag.length - i * 2 - 1; j++) {
				zigzag[i][i + j] = number++;
			}
			for (int j = 0; j < zigzag.length - i * 2 - 1; j++) {
				zigzag[i + j][zigzag.length - i - 1] = number++;
			}
			for (int j = 0; j < zigzag.length - i * 2 - 1; j++) {
				zigzag[zigzag.length - i - 1][zigzag.length - i - 1 - j] = number++;
			}
			for (int j = 0; j < zigzag.length - i * 2 - 1; j++) {
				zigzag[zigzag.length - i - 1 - j][i] = number++;
			}
			
		}
		
        //遍历输出回形数矩阵
		for (int i = 0; i < zigzag.length; i++) {
			for (int j = 0; j < zigzag.length; j++) {
				System.out.print(zigzag[i][j] + "\t");
			}
			System.out.println();
		}
	}
}

/*运行结果
请输入矩阵宽度:5
1	2	3	4	5	
16	17	18	19	6	
15	24	25	20	7	
14	23	22	21	8	
13	12	11	10	9
*/
```



#### 3.4.2 数值型数组中元素的计算

```java
//取int型数组元素中的最大值、最小值、平均数、总和
public class ArrayTest {
	public static void main(String[] args) {
		
		int[] arr = new int[10];
		int max = 0;
		int min = 100;
		int sum = 0;
		double avg = 0;
		
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int)(Math.random() * 90 + 10);
			
			if (arr[i] > max) {
				max = arr[i];
			}
			
			if (arr[i] < min) {
				min = arr[i];
			}
			
			sum += arr[i];
		}
		
		avg = sum / 10.0;
		
		System.out.println("最大值为:" + max);
		System.out.println("最小值为:" + min);
		System.out.println("和值为:" + sum);
		System.out.println("平均值为:" + avg);
	}

}
```



#### 3.4.3 数组的复制、反转、查找

```java
//数组的复制
int[] arr1 = {1,2,3};
int[] arr2 = new int[arr1.length];
for (int i = 0; i < arr1.length; i++){
	arr2[i] = arr1[i];
}
```

```java
//数组的反转
int[] arr = {1,2,3,4,5};
for (int i = 0, i < arr.length/2; i++){
	int temp = arr[i];
	arr[i] = arr[arr.length - 1 - i];
	arr[arr.length - 1 - i] = temp;
}
```

```java
//线性查找
int[] arr = {1,2,3,4,5};
int target = 4;
boolean isFind = true;
for (int i = 0; i < arr.length; i++){
	if (arr[i] == target){
		System.out.println(i);
		isFind = false;
		break;
	}
}
if (isFind){
	System.out.println("未找到");
}

```

```java
//二分法查找：数组必须是有序的
public class BinarySearch {
	public static void main(String[] args) {
		
		int[] arr = new int[]{-99,-54,-2,0,2,33,43,256,999};
		boolean isFlag = true; 
		int target = 128;
		
		for (int head = 0, end = arr.length - 1;head <= end;) {
			int middle = (head + end) / 2;
			if (arr[middle] == target) {
				System.out.println("[index]:" + middle);
				isFlag = false;
				break;
			}else if (arr[middle] < target) {
				head = middle + 1;
			}else {
				end = middle - 1;
			}
		}
		
		if (isFlag) {
			System.out.println("未找到" + target);
		}
	}

}
```



#### 3.4.4 数组元素的排序算法

- 排序：假设含有n个记录的序列为{R1，R2，...,Rn},其相应的关键字序列为{K1，K2，...,Kn}。将这些记录重新排序为{Ri1,Ri2,...,Rin},使得相应的关键字值满足条Ki1<=Ki2<=...<=Kin,这样的一种操作称为排序。

- 衡量排序算法的优劣：

  - 时间复杂度：分析关键字的比较次数和记录的移动次数；
  - 空间复杂度：分析排序算法中需要多少辅助内存；
  - 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。

- 排序算法的分类：

  - 内部排序：整个排序过程不需要借助与外部存储器（如磁盘等），所有排序操作都在内存中完成；
  - 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程都放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序，可以认为外部排序是由多次内部排序组成。

- 十大排序算法

  - 选择排序：直接选择排序，堆排序；
  - 交换排序：**冒泡排序、快速排序**；
  - 插入排序：直接插入排序、折半插入排序、shell排序；
  - 归并排序；
  - 桶式排序；
  - 基数排序；

- 算法的五大特征

  - 输入（input）：有0至多个数据输入，这些输入必须有清楚的描述和定义；
  - 输出（output）：至1至多个输出结果，不可以没有输出；
  - 有穷性（finiteness）：算法在有限的步骤之后会自动结束而不是无限循环，并且每一个步骤都可以在可接受的时间完成；
  - 确定性（definiteness）：算法的每一步都有确定的含义，不会出现二义性；
  - 可行性（effectiveness）:算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案；

  ```java
  //冒泡排序
  int[] arr = new int[]{34,5,22,-98,6,-76,0,-3};
  
  for (int i = 0; i < arr.length - 1; i++) {
  	for (int j = 0; j < arr.length - 1 - i; j++) {
  		if (arr[j] > arr[j + 1]) {
  			int temp = arr[j];
  			arr[j] = arr[j + 1];
  			arr[j + 1] = temp;
  		}
  	}
  }
  
  //快速排序
  /*
  排序思想：
  1.从数列中挑出一个元素，称为“基准”（pivot）；
  2.重新排序数列，所有比基准值小的元素排放在基准值的前面，所有比基准值大的元素排放在基准值后面，在这个分区结束之后，该基准就处于数列的中间位置，这个称为分区（partition）操作；
  3.递归地把小于基准值元素的子数列和大于基准值元素的子数列排序；
  4.递归的底部是数列的长度为0或1。
  
  快速排序的时间复杂度为O(nlog(n))
  */
  ```



- 各种内部排序方法性能的比较
  - 平均时间比较：快速排序最佳，但在最坏情况下时间性能不如堆排序和归并排序；
  - 算法简单性比较：直接选择排序、直接插入排序和冒泡排序属于简单排序算法，shell排序、堆排序、快速排序和归并排序属于复杂排序算法；
  - 稳定性比较：直接插入排序、冒泡排序和归并排序是稳定排序，直接选择排序、快速排序、shell排序和堆排序是不稳定排序；
  - 从待排序的记录数n的大小比较：n较小时宜采用简单排序，n较大时宜采用改进排序。



### 3.5 Arrays工具类的使用

| 语法                               | 说明                             |
| ---------------------------------- | -------------------------------- |
| boolean equals(int[] a, int[] b)   | 判断两个数组是否相等             |
| String toString(int[] a)           | 输出数组信息                     |
| void fill(int[] a, int val)        | 将指定填充到数组之中             |
| void sort(int[] a)                 | 对数组进行排序（快速排序）       |
| int binarySearch(int[] a, int key) | 对排序后的数组用二分法检索指定值 |



### 3.6 数组使用中的常见异常

```java
// ArrayIndexOutOfBoundsException数组脚标越界异常：访问了数组中不存在的脚标时报错
int[] arr = new int[5];
System.out.println(arr[5]);
System.out.println(arr[-1]);

//NullpointerException 空指针异常，访问的数组中的元素没有初始化，即没有地址
int[] arr1 = null;
System.out.println(arr1[5]);
int[][] arr2 = new int[5][];
System.out.println(arr2[5][0]);
```



## 第四章 面向对象编程（上）

### 4.1 面向过程与面向对象	

- 面向过程（Procedure Oriented Programming）：强调的是功能行为，以函数为最小单位，考虑怎么做。
- 面向对象（Object Oriented Programming）：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
- 面向对象的三大特征：
  - 封装
  - 继承
  - 多态



### 4.2 Java语言的基本元素：类和对象

- 类（class）：对一类事物的描述，是抽象的、概念上的定义；
- 对象（object）：实际存在的该类实物的每个个体，因而也称为实例。



### 4.3 对象的创建和使用

#### 4.3.1 创建类

```java
class Phone{
	String name;
	int price;
	
	public void call(){
		System.out.println("手机可以打电话");
	}
	
	public void sendMessage(String message){
		System.out.println("发送短信：" + message);
	}
}
```

#### 4.3.2 创建类的对象，调用属性和方法

```java
public class PhoneTest{
	public static void main(String[] args){
		Phone p1 = new Phone();
		p1.name = "小米10";
		p1.price = 3999;
		p1.call();
		p1.sendMessage("无内鬼");
	}
}
```

- 创建好的对象只能调用其所在类中声明过的属性和方法；
- 如果创建一个类的多个对象，则每个对象都拥有一套类中的属性的副本。修改其中一个对象的属性值，不会影响到其他对象此属性的值；
- Phone p2 = p1中，p2复制的是p1的地址值，两个变量指向堆空间中的同一个对象； 

#### 4.3.3 匿名对象

- 匿名对象：创建的对象是匿名的，因为没有变量名，所以只能调用一次

```java
//继续以Phone类举例
public class PhoneTest{
	public static void main(String[] args){
		new Phone().call;
		//直接输出“手机可以打电话”
	}
}
```



### 4.4 类的成员之一：属性（field）

- 属性 = 成员变量 = field = 字段 = 域
- 成员变量与局部变量的对比
  - 相同点：
    - 变量声明初始化的格式相同；
    - 变量必须先声明、再初始化、再使用；
    - 变量都有对应的作用域，并只在作用域内生效。
  - 不同点：
    - 声明的位置不同：
      - 成员变量：直接声明在类中；
      - 局部变量：声明在方法、方法的形参、构造器、代码块内部。
    - 权限修饰符的使用不同：
      - 成员变量：在数据类型前可使用权限修饰符进行修饰（public/protected/缺省/private）；
      - 局部变量：不可使用权限修饰符修饰。
    - 默认初始化值不同：
      - 成员变量：若在声明时没有显式赋值，则数据默认值遵循数组元素的默认初始化值；
      - 局部变量：使用前必须进行显式初始化
    - 内存中保存的位置不同：
      - 成员变量：在堆空间中分配内存；
      - 局部变量：在栈空间中分配内存。
- 注意：在方法内可以使用类的成员变量，但在方法内不能使用其他类中定义的局部变量。



### 4.5 类的成员之二：方法（method）

- 方法是对类或对象行为特征的抽象，用来完成某个功能操作，在某些语言中也被称为函数或过程。
- Java中的方法不能独立存在，所有的方法必须定义在类里。

```java
//方法声明的格式
修饰符 返回值类型 方法名 (参数类型 形参1, 参数类型形参2,...){
	方法体;
	return //返回值
}

//举例
public void show(){
	System.out.println("HelloWorld");
}
```

- 没有返回值时，返回值类型使用void关键字表示，同时方法体中可以不使用return关键字；
- 方法内可以调用类的方法或属性，但不能在方法内定义方法；
- return关键字的作用
  - 对于没有返回值的方法，用于结束该方法，return后不可再编写执行语句；
  - 对于有返回值的方法，return用于返回该返回值，return后字段的数据类型必须与返回值类型一致。



### 4.6 方法深入

#### 4.6.1 方法的重载（overload）

- 概念：在同一个类中，允许存在一个以上的同名方法，只需同名方法的参数个数或参数类型不同即可。
- 特点：与方法的返回值类型无关，只与方法名和参数列表有关（Java程序调用方法时依靠方法名和给定实参区分调用的具体方法）。
- 注意
  - **对于形参类型为子父类的重载方法，当参数同时满足两个方法时，系统会执行形参类型为子类（较近的继承类）的方法**。
  - **对于形参为不同基本数据类型的重载方法，当参数同时满足两个方法时，系统会执行形参精度更接近的方法**



#### 4.6.2 可变形参的方法

```java
//格式(例)：
public void show(String ... str){}
```

- 可变形参的方法在调用时，形参的个数可以是0个、1个或多个；
- 可变形参的方法与类中的同名方法构成重载（形参为数组除外），因为可变形参的使用与数组的使用格式是一致的；

```java
public void show(String ... str){
	for (int i = 0; i < str.length; i++){
		System.out.println(str[i]);
	}
}
```

- 可变形参的方法可以接收同数据类型的可变实参，也可以接受同数据类型的数组，但形参为数组的方法即使元素的数据类型相同也不可接收可变实参。
- 在一个方法中，若有多个参数，则可变形参必须放在最后声明；
- 一个方法最多只能声明一个可变形参。



#### 4.6.3 方法参数的值传递机制

- 形参：方法声明时的参数；
- 实参：方法调用时实际传给形参的参数值；
- 值传递（Java方法的唯一参数传递机制）
  - 基本数据类型：将实参中基本数据类型变量的“数据值”传递给相应形参；
  - 引用数据类型：将实参中引用数据类型变量的“地址值”传递给相应形参。
- String的不可变性：当形参数据类型为String时，实参传入后，方法中的执行语句不对原实参产生任何影响。

```java
int i = 0;
i = i++;
System.out.println(i);
//输出结果为0
//执行顺序：先取=右边i的值0，i再自增1，最后把取到的0赋给=左边的i

int i = 0;
i = ++i;
System.out.println(i);
//输出结果为1
//执行顺序：i先自增1，再取=右边i的值1，最后把取到的1赋给=左边的i
```



#### 4.6.4 递归方法

- 概念：一个方法中调用它本身的方法；

- 递归方法实际包含了一种隐式循环，会重复执行某段代码，且无需循环控制；

- 方法的递归必须向已知方向递归，否则会形成无穷递归（死循环）。

  ```java
  //递归方法：求100以内自然数和
  public int sum(int num){
  	if (sum = 1){
  		return 1;
  	}else{
  		return num + sum(num - 1);
  	}
  }
  ```



### 4.7 封装性

- 程序设计追求：
  - 高内聚：类的内部数据操作细节自己完成，不允许外部干涉；
  - 低耦合：仅对外暴露少量的方法用于使用。
- 四种访问权限修饰符

| 权限修饰符 | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| ---------- | ------ | -------- | ------------ | ---------- |
| private    | yes    |          |              |            |
| (缺省)     | yes    | yes      |              |            |
| protected  | yes    | yes      | yes          |            |
| public     | yes    | yes      | yes          | yes        |

- 四种权限修饰符置于**类的成员(属性、方法、构造器、内部类)**定义前，用来限定对象对该类成员的访问；
- 修饰**类**只可以使用public和default(缺省)
  - public类可以在同一个工程内被访问；
  - default类只能在同一个包内被访问。
  
  

### 4.8 类的成员之三：构造器（constructor）

#### 4.8.1 构造器

- 构造器的特征：

  - 构造器名与类名相同；
  - 构造器不声明返回值类型；
  - 不被static、final、synchronized、abstract、native修饰，**可以有return语句结束构造**，但不能有返回值。

- 构造器的作用：

  - **创建对象**；
  - 初始化对象的属性信息。

- 构造器的说明：

  - 在未显式定义时，系统会为类提供一个默认的隐式无参构造器；

  - 声明构造器的格式

    ```
    权限修饰符 类名(形参列表) {}
    ```

  - 一旦显式定义了一个构造器，默认的无参构造器就不存在了；

  - 一个类中可以有一至多个构造器，多个构造器之间构成了重载；



#### 4.8.2 属性赋值过程

1.  默认初始化

   ```java
   int i;
   ```

2.  显式初始化

   ```java
   int i = 1;
   ```

3.  构造器中初始化

   ```java
   public Test(){
   	i = 1;
   }
   ```

4. 通过“对象.属性”或“对象.方法”的方式赋值

   ```java
   public void setI(int input){
   	i = input;
   }
   ```

   

#### 4.8.3 JavaBean

- 概念：JavaBean是一种Java语言写成的可重用组件；
- 标准：
  - 类是公共的；
  - 有一个公共的无参构造器；
  - 有属性及其相应的get、set方法。



#### 4.8.4 UML类图

![image-20200226203417115](java上.assets\image-20200226203417115.png)

- 权限修饰符：+表示public，-表示private，#表示protected；

- 方法的写法；

  ```
  (+/-/#/ ) 方法名(形参名:参数类型)
  ```

- 下划线表示构造器。



### 4.9 this关键字

- this调用属性、方法

  - 在方法和构造器内，可以使用"this.aaa"表示属性aaa，用于区分属性和局部变量（如同名形参）；

    ```java
    class Student{
    	private String name;
    	
    	public void setName(String name){
    	this.name = name;
    	}
    }
    ```

    

- this调用构造器

  - 在类的构造器中，可以使用"this(形参列表);"的方式调用本类中的其他构造器；

  - 若一个类中有n个构造器，则最多存在n-1个构造器调用了其它构造器，否则调用会出现死循环；

  - this调用其它构造器的语句必须写在构造器的首行；

  - 一个构造器中最多调用一个其它构造器。

    ```java
    class Student{
    	private String name;
    	private int age;
    	
    	public Student(String n){
    		name = n;
    	}
    	
    	public Student(int a){
    		this("A");
    		age = a;
    	}
    }
    ```



### 4.10 package和import关键字

- package（包）

  - 在Java工程中，每个java类所在的文件首行都需要声明当前类所属的包；

    ```java
    package com.java.exer;
    ```

  - 包名需满足标识符的命名规则和规范并见名知意；

  - "com.java.exer"中的每一个"."代表一层文件目录。

- import（导包）

  - import关键字用于显式的导入指定包下的结构：类、接口；

  - import语句写在包的声明和类的声明之间；

    ```java
    package com.java.exer;
    
    import java.util.Scanner;
    
    class Person{}
    ```

  - 多个包的导入可使用import语句并列声明；

    ```java
    import java.util.Scanner;
    import com.java.exer.Person;
    ```

  - 可使用"*"一次性导入一个包下的全部内容；

    ```java
    import java.util.*;
    ```

  - **java.lang及当前代码所在包**下的类或接口无需显式导入；

  - 对于同一项目不同包下的同名类：

    - 未导包时，默认调用本包下的相应类；

    - 导包后，默认调用导包中的类；

    - 若都需使用，则需要导包，本包下的同名类需使用全类名调用。

      ```java
      Person p1 = new Person();
      com.java.exer.Person p2 = new com.java.exer.Person();
      ```

    - 注意：系统一定会按照默认规则调用对应类的包下的类，不会根据类中构造器的形参不同自动适配选择，换句话说同名的不同类的构造器不构成重载，所以系统不识别。



## 第五章 面向对象编程（中）

### 5.1 继承性

- 多个类中存在相同的属性和方法时，为了不反复定义这些相同的属性和方法，减少代码冗余，就出现了继承（inheritance）；

- 把封装了需要复用的属性、方法的类称为父类（基类、超类），而要继承这些属性方法的类则称为子类（派生类）；

- 语法：

  ```java
  class Student extends Person(){}
  ```

- 作用：

  - 减少代码冗余，提高代码的复用性；
  - 有利于功能的扩展；
  - 使类与类之间产生联系，提供多态的前提。

- **子类继承了父类中所有的属性和方法，但子类无法直接访问父类中private权限的属性和方法**；

- 单继承性：一个子类只能有一个直接父类，而一个父类可以有多个子类；

- 子类除了不仅继承了直接父类中的结构，也继承了间接父类中的结构。



### 5.2 方法的重写（override/overwrite）

- 概念：子类可以根据需要对从父类继承的方法进行改造，也称为方法的重置、覆盖。程序执行时会直接调用子类中重写的方法；
- 要求：
  - 子类重写的方法必须与父类被重写的方法具有**相同的方法名和形参列表**；
  - 子类重写的方法的返回值类型**不能大于**父类被重写的方法的返回值类型；
    - 若父类方法返回值类型为void，子类重写方法的返回值也必须为void；
    - 若父类方法返回值类型为基本数据类型，子类重写方法的返回值也必须为相同的基本数据类型；
    - 若父类方法返回值类型为引用数据类型，子类重写方法的返回值也必须为相同的引用数据类型或为该引用数据类型的子类。
  - 子类重写的方法的访问权限**不能小于**父类被重写的方法的访问权限，子类**不能重写**父类中声明为**private权限**的方法；
  - 子类方法抛出的异常不能大于父类被重写方法的异常。
  - 子父类中同名同参数的方法必须同时为static的（static修饰的方法不能重写），或者同时为非static的（重写）。



### 5.3 四种访问权限修饰符

- protected权限说明
  - 定义：一个类中声明为protected权限的属性或方法，可以被不同包下、该类的子类调用。
  - **要明确调用者是谁，在main方法中创建某类的对象后，可能无法直接调用该类的父类中权限为protected的属性方法，因为调用者是main方法所在类。**
- 其他权限参考4.7中的四种权限修饰符所对应的的权限。



### 5.4 super关键字

- super关键字可理解为“父类的”意思；

- 功能：

  - 调用父类中的属性、方法：
    - 当子类需要调用父类中的属性/方法()时，使用super.属性/方法()的格式调用，但通常省略；
    - 当子类中包含和父类重名的属性时，若要调用父类中的属性，则必须使用super.属性的方式调用；
    - 当子类中包含重写的方法时，若要调用父类中被重写的方法，则必须使用super.方法()的方式调用。
  - 调用父类中的构造器：
    - 使用super(形参列表)的格式显式地调用父类中的构造器；
    - 当构造器首行既没有显式地使用this(形参列表)或super(形参列表)调用其他构造器时，实际上默认调用了super()结构；
    - super()和this()同样在使用时必须声明在构造器首行，因此二者不能同时存在。

- 若一个类没有显式声明其父类，则系统默认该类的父类为java.lang.Object类。

- **当使用子类的对象调用父类的方法时，父类的方法在调用属性时会获取父类中的属性而非子类中的同名属性。在子父类关系中，方法和属性的的调用支持向上（向父类）追溯，反之向下（向子类）不行，若需要调用子类中的同名属性，必须重写父类的相应方法后在该方法中调用。**

  ```java
  public class Test3 {
      public static void main(String[] args) {
          Son s = new Son();
          System.out.println(s.getInfo());
          s.test();
          System.out.println("-----------------");
          s.setInfo("大硅谷");
          System.out.println(s.getInfo());
          s.test();
      }
  }
  
  class Father {
      private String info = "atguigu";
  
      public void setInfo(String info) {
          this.info = info;
      }
  
      public String getInfo() {
          return info;
      }
  }
  
  class Son extends Father {
      private String info = "尚硅谷";
  
      public void test() {
          System.out.println(this.getInfo());
          System.out.println(super.getInfo());
      }
  }
  
  ```




### 5.5 子类对象实例化过程

- 通过子类的构造器创建对象时，子类的构造器一定会直接(super)或间接(this)地调用到父类的构造器，直到调用了java.lang.Object类的构造器为止。因此一定会加载所有直接或间接父类的结构。
- 创建子类的对象时，虽然调用了多个构造器，但自始至终只有一个对象。



### 5.6 多态性

- 子类对象的多态性：父类的引用指向子类的对象。

  ```java
  Person p2 = new Man();
  ```

- 多态性的应用：虚拟方法(virtual method)的调用

  - **编译时，引用变量只能调用声明的父类对象中的方法，运行时，实际执行的是子类中重写的方法（方法的调用者依然是父类对象）**；
  - 总结：编译看左，运行看右；
  - 父类的对象即使使用子类的构造器创建，也无法直接调用子类中新增的属性或方法，必须通过虚拟方法的形式调用。

- 多态性使用的前提

  - 子父类的继承关系；
  - 重写的方法。

- 多态性只适用于方法，不适用于属性。



#### 5.6.1 instanceof操作符

```java
x instanceof A
//检验x是否是A类的对象，返回值为boolean类型
```

- 当x为类A或类A的子类的对象时，返回true，否则返回flase；

- 对象类型转换（Casting）

  - 从子类到父类的类型转换可以自动进行（父类的形参可以接受子类的对象）；

  - 从父类到子类的类型转换必须通过造型（强制类型转换）实现；

    ```java
    Person p = new Man();
    Man m = (Man)p;
    ```

  - 无继承关系的引用数据类型之间是不能相互转化的（非法）；

  - 在强制类型转换前需要先使用instanceof判断是否可以强转。



### 5.7 Object类的使用

- Object类是Java所有类的根父类；
- ==操作符与equals方法
  - ==运算符
    - 基本数据类型：比较两者的数据值是否相等；
    - 引用数据类型：比较两者是否指向同一个对象（地址值）；
  - equals方法
    - Object类中：比价两者是否指向同一个对象；
    - File、String、Date及包装类中：比较具体内容，equals方法被重写；
    - 自定义类中：可以重写，用于比较对象的具体属性。
- toString方法
  - Object类中：返回类名和对象的引用地址；
  - 打印一个具体的对象实例时，默认调用的是它的toString方法；
  - File、String、Date及包装类中：重写了toString方法，用于输出具体的内容信息；
  - 自定义类中：可以重写，用于获取对象的属性等信息。



### 5.8 包装类的使用

- 针对8种基本数据类型定义相应的引用类型——包装类；

- 基本数据类型与包装类的对应关系

  | 基本数据类型 | 包装类        |
  | ------------ | ------------- |
  | byte         | Byte          |
  | short        | Short         |
  | int          | **Integer**   |
  | long         | Long          |
  | float        | Float         |
  | double       | Double        |
  | char         | **Character** |
  | boolean      | Boolean       |

- 包装类的构造器

  ```java
  Integer i = new Integer(7);
  Integer i = new Integer(i);
  Integer i = new Integer("7");
  //i为int型变量，三种均可接收
  ```

  - 可接收的形参：对应的基本数据类型常量，对应的基本数据类型，String型（去掉双引号后为该基本数据类型常量）；
  - 对于Boolean类的构造器形参，形参为String型时，若不是“true”（大小写均可），则视为false。

- 包装类的方法

  - 实例方法1：xxxValue()	无形参，包装类 → 基本数据类型

    ```java
    Integer i1 = new Integer(7);
    int i2 = i1.intValue();
    //JDk5.0后引入自动装箱拆箱，此方法可直接写为
    Integer i1 = 7;
    int i2 = i1;
    ```

  - 实例方法2：toString()  无形参，包装类 → String

    ```java
    Integer i1 = new Integer(7);
    String s1 = i1.toString();
    ```

    

  - 类方法1：**Xxx.parseXxx()  有形参 String → 包装类/基本数据类型**

    ```java
    int i = Integer.parseInt("123");
    Integer i = Integer.parseInt(str);
    ```

  - 类方法2：toString()  有形参 包装类/基本数据类型 → String

    ```java
    String s1 = Integer.toString(123);
    ```

- String类的方法

  - 类方法：valueOf() 有形参 包装类/基本数据类型 → String

    ```java
    String s1 = String.valueOf(123);
    String s2 = String.valueOf(i);
    ```
  
- 关于自动装箱、拆箱

  ```java
  Integer i1 = 128;
  Integer i2 = 128;
  int i3 = 128;
  int i4 = 128;
  System.out.println(i1 == i2);//false，引用数据类型之间比较地址值
  System.out.println(i3 == i4);//true，基本数据类型比较数据值
  System.out.println(i1 == i3);//true，i1自动拆箱
  //包装类对象与基本数据类型进行比较时，就会把包装类对象自动拆箱，按照基本数据类型的规则进行比较
  ```
  



## 第六章 面向对象编程（下）

### 6.1 static关键字

- static：静态的；
- static可以修饰的结构：属性、方法、代码块、内部类；
- static修饰后的结构特点：
  - 随着类的加载而加载，随着类的消失而消失；
  - 优先于对象存在；
  - 所有类的对象共享；
  - 访问权限允许时，可以不创建对象，直接被类调用



#### 6.1.1 类属性（类变量）

- 成员变量

  - 静态变量（类变量）
  - 非静态变量（实例变量）

- 属性被static修饰后即为类属性；

  ```java
  private static int number;
  ```

  通过一个对象修改类属性后，所有对象的该属性都会被修改；

- 类变量随着类的加载而加载，且只会加载一次，存储在内存的静态域中；（ps：实例变量随着对象的创建才创建）

  | 调用方式 | 类变量 | 实例变量 |
  | -------- | ------ | -------- |
  | 类.xxx   | 可调用 | 不可调用 |
  | 对象.xxx | 可调用 | 可调用   |



#### 6.2.2 类方法

- 静态方法中，只能调用当前类中的静态结构，不能调用非静态结构；

- 静态方法内，**不能使用this、super关键字**；

- static修饰的方法不能被重写；

  | 调用方式   | 类方法 | 实例方法 |
  | ---------- | ------ | -------- |
  | 类.xxx()   | 可调用 | 不可调用 |
  | 对象.xxx() | 可调用 | 可调用   |



#### 6.2.3 单例设计模式

- 单例设计模式设计的类**只能存在一个实例对象**；

- 饿汉式

  ```java
  class Hungry{
  	//创建私有的构造器
  	private Hungry(){}
  	//提供一个当前类的静态化实例
  	private static Hungry h = new Hungry();
  	//提供公共的get方法，返回实例
  	public Hungry getHungry(){
  		return h;
  	}
  }
  ```

- 懒汉式

  ```java
  class Lazz{
  	//创建私有的构造器
  	private Lazz(){}
  	//声明一个当前类类型的静态化属性
  	private static Lazz l = null;
  	//提供公共的get方法，若实例未初始化则调用构造器初始化并返回实例，否则直接返回实例
  	public Lazz getLazz(){
  		if (l == null){
  			l = new Lazz();
  			return l;
  		}
  		return l;
  	}
  }
  ```

- 饿汉式与懒汉式对比

  - 从节省内存空间的角度看：懒汉式较好；
  - 从线程安全性的角度看：饿汉式较好。



### 6.2 理解main方法的语法

```java
public static void main(String[] args){}
```

- **mian()方法是程序的入口**，由于Java虚拟机需要调用类的main()方法，所以该方法的**访问权限必须是public**；
- 因为Java虚拟机在执行main()方法时不用创建对象，所以该方法**必须是static的**，该方法接收一个String型的数组参数，该数组中保存执行Java命令时给所运行的类的参数。
- 因为main()方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。



### 6.3 类的成员之四：代码块

- 代码块的作用：对Java类或对象进行初始化；

- 代码块只能被static修饰，分为静态和非静态代码块

  - 静态代码块（用static修饰的代码块）

    ```java
    static{
    	System.out.println("静态代码块")
    }
    ```

    - 可以有输出语句；
    - 可以对类的属性、类的声明进行初始化；
    - 不可以调用非静态的属性和方法；
    - 多个静态代码块自上而下依次执行；
    - 静态代码块随着类的加载而加载，且只执行一次。

  - 非静态代码块

    ```java
    {
    	System.out.println("非静态代码块")
    }
    ```

    - 可以有输出语句；
    - 可以对类的属性、类的声明进行初始化；
    - 可以调用静态或非静态的属性和方法；
    - 多个非静态代码块自上而下依次执行；
    - 每创建一个类的对象，非静态代码块执行一次，且先于构造器执行。

#### 6.3.1 内存中的赋值顺序

对于同时包含类属性、实例属性、静态代码块、非静态代码块、构造器的子类对象创建时，属性的赋值顺序如下：

- **加载阶段**（main方法所在类最先加载）：

1. 父类类属性按照数据类型默认初始化；
2. 父类类属性显式赋值/父类静态代码块显式赋值；
3. 子类类属性按照数据类型默认初始化；
4. 子类类属性显示赋值/子类静态代码块显式赋值；

- **实例化阶段**：

1. 父类实例属性默认初始化；
2. 父类实例属性显式赋值/父类非静态代码块显式赋值；
3. 父类构造器显式赋值；
4. 子类实例属性默认初始化；
5. 子类实例属性显式赋值/子类非静态代码块显式赋值；
6. 子类构造器显式赋值；

- **执行阶段**：

1. 通过对象.属性/对象.方法的方式给类属性/实例属性赋值。



### 6.4 final关键字

- final：最终的；

- final可以修饰的结构：类、方法、变量（成员变量或局部变量）

- final修饰类：该类不可被继承；

  ```java
  public final String{}
  ```

- final修饰方法：该方法不可被子类重写；

  ```java
  public final void sort(int[] arr)
  ```

- final修饰变量

  - 成员变量：必须在声明时/代码块中/构造器中显示赋值一次，即为常量，注意常量的命名规范（所有字母大写，下划线连接单词）；

    ```java
    private final int ID = 999;
    ```

  - 局部变量：主要用于修饰方法形参，使得形参传入后不能再被赋值，对于引用数据类型形参，可理解为不能改变对象的指向；

    ```java
    public void setID(final int i){}
    ```

  - static final：全局常量 ，如Math.PI。



### 6.5 抽象类与抽象方法

- abstract：抽象的；

- abstract可以用来修饰类或方法；

- 抽象类：

  ```java
  public abstract class Person(){}
  ```

  - 不能被实例化，主要用于被子类继承；
  - 抽象类有构造器，在子类实例化对象时被调用。

- 抽象方法：

  ```java
  public abstract findArea();
  ```

  - 只有在抽象类中才能声明抽象方法；
  - 无方法体，注意有";"
  - 若子类不是抽象类，则必须重写父类中的全部的抽象方法。

- 不能用abstract修饰：

  - 私有方法：子类不能重写父类中声明为private的方法；
  - 静态方法：抽象方法无方法体，直接调用没有意义；
  - final的方法、类：抽象类和抽象方法本身就是为了实现多态性而存在，而final类不可继承，final方法不可重写，完全背道而驰。

- 抽象的应用：模版方法设计模式

  - 在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现，这就是一种模版模式。



### 6.6 接口（Interface）

- **接口使用关键字Interface定义，是与类并列的结构，只能只用public/缺省修饰接口权限**；

  ```java
  public interface Person {...}
  ```

- 接口中的结构（5种，除private方法外其余结构权限均为public）：

  - **全局常量（public static final）**

    ```java
    public static final String nation = "China";
    String nation = "China";//省略了public static final，也可省略其中一到两个关键字，含义同上
    //仅此两种声明方式，也是接口中唯一可定义的属性
    ```

  - **抽象方法（public abstract）**

    ```java
    public abstract void fly();//格式同抽象类中抽象方法的定义
    void fly();//省略了public abstract，也可省略其中一个关键字，含义同上
    ```

  - （JDK8.0后）**静态方法（public static）**，**可通过接口直接调用静态方法**，**但实现类和实现类的对象均不可调用接口的静态方法**

    ```java
    public static void fly(){}//同类的静态方法定义方式
    static void fly(){}//省略了public，含义同上
    ```

  - （JDK8.0后）**默认方法（public default）**，**需要通过实现类对象调用**

    ```java
    public default void fly(){}
    default void fly(){}//省略了public，含义同上
    ```

  - （JDK9.0后）**私有方法（private）**，供类中其他的默认/私有方法调用

    ```java
    private void fly(){}//同类的私有方法定义方式
    ```

- 类与接口的关系

  - 使用implements使类实现接口，声明在继承关系后；

    ```java
    class A implements C {...}
    class A extends B implements C {...}
    ```

  - 实现类本身、实现类的父类、实现类的接口中出现**同名属性时的调用规则**

    - 若实现类与实现类的父类/实现类的接口出现同名属性，默认调用实现类中的属性；
    - 若实现类的父类与实现类的接口中出现同名属性，或实现类的接口与接口中出现同名属性，则必须用super/接口名调用；

    ```java
    this.aaa;//调用实现类属性
    super.aaa;//调用父类属性
    接口名.aaa;//调用接口全局常量
    ```

  - 接口的实现类中，**必须重写接口中的所有抽象方法**，否则该类需定义为抽象类，且无法实例化（与抽象类的子类类似）；

  - 接口有多继承机制：**一个实现类可以同时实现多个接口**；

    ```java
    class A implements B,C {...}
    ```

  - **同名同参方法的处理**

    ```java
    //1. 当实现类实现了了两个以上的接口，且其中有至少两个接口中包含同名同参的默认方法时，则实现类必须重写该方法，否则编译不通过
    //2. 重写后，若实现类的对象需要调用接口中的被重写方法，语句如下
    class A implements B,C {  
        public void fly(){
            method();//调用A中重写后的方法
            B.super.method();//调用B中重写前的默认方法
            C.super.method();//调用C中重写前的默认方法
        }
    }
    //3. 当实现类继承的父类和实现的接口中，含有同名同参的方法时，此时无需重写，系统默认优先调用父类的方法
    class A extends B implements C {  
        public void fly(){
            method();//调用父类B中的方法，若A中已重写此方法，则使用super.method();调用
            C.super.method();//调用C中的默认方法
        }
    }
    ```
    
  - 接口的匿名实现类

    ```java
    Computer c1 = new Computer();
    
    //1. 创建接口实现类的非匿名对象
    Flash flash = new Flash();
    c1.transferData(flash);
    
    //2. 创建接口实现类的匿名对象
    c1.transferData(new Printer());
    
    //3. 创建接口匿名实现类的非匿名对象
    USB usb1 = new USB(){
    
        @Override
        public void start() {
            System.out.println("mp3开始工作");
        }
    
        @Override
        public void stop() {
            System.out.println("mp3结束工作");
        }
    
    };
    c1.transferData(usb1);
    
    //4. 创建接口匿名实现类的匿名对象
    c1.transferData(new USB(){
    
        @Override
        public void start() {
            System.out.println("手机开始工作");
        }
    
        @Override
        public void stop() {
            System.out.println("手机结束工作");
        }
    
    });
    ```

    

- 接口与接口之间可以继承（inheritance），且支持多继承；

  ```
  interface A extends B,C {...}
  ```

  

### 6.7 内部类

- 定义：在Java中，允许一个类定义在另一个类的内部，前者称为内部类，后者称为外部类；

- **内部类不能与外部类重名**；

- 内部类的分类

  - 成员内部类（静态成员内部类、非静态成员内部类）

    ```java
    //创建静态成员内部类
    class Person {
    	class Dog{}
    }
    Person.Dog d1 = new Person.Dog();
    
    //创建非静态成员内部类
    class Person {
    	class Dog{}
    }
    Person p = new Person();
    Person.Dog d2 = p.new Dog();//必须通过外部类的对象调用内部类的构造器
    ```

    - **可以使用4种权限修饰符修饰**；

    - 非静态成员类可以调用外部类的全部结构；

      ```java
      class Person {
      	String name;
      	class Dog{
      		String name;
      		public void getName{
      			System.out.println(this.name);//调用内部类的属性
      			System.out.println(Person.this.name);//调用外部类的属性
      		}
      	}
      }
      ```

    - 可以声明为static，**静态成员内部类只能调用外部类的静态结构**；

    - 和外部类同样可以定义属性、方法、构造器、代码块、内部类；

    - 可以被abstract修饰；

    - 可以被final修饰；

    - 只有静态成员内部类中可以声明static结构，非静态成员内部类不能声明static结构；

    - **外部类访问内部类的成员可通过“内部类.成员”或“内部类对象.成员”的方式调用**。

  - 局部内部类

    - 只能声明在方法或代码块中，且只能在其中使用，遵循先声明后使用；
    - 可以调用外部类的全部结构，还可以使用外部方法的final局部变量；
    - 不能使用权限修饰符修饰，类本身及内部成员不能使用static声明；

  - 匿名内部类
  
    ```java
    //编写一个Object类的匿名内部类，并在匿名内部类中，声明一个方法public void test()打印atguigu
    public class InnerDemo {	
    	public static void main(String[] args) {
    		
    		new Object() {
    			public void test() {
    				System.out.println("atguigu");
    			}
    		}.test();
    		
    	}	
    }
    ```
    



### 附：Eclipse常用快捷键

```java
Eclipse中的快捷键：
 * 1.补全代码的声明：alt + /
 * 2.快速修复: ctrl + 1  
 * 3.批量导包：ctrl + shift + o
 * 4.使用单行注释：ctrl + /
 * 5.使用多行注释： ctrl + shift + /   
 * 6.取消多行注释：ctrl + shift + \
 * 7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up
 * 8.删除指定行的代码：ctrl + d
 * 9.上下移动代码：alt + up  或 alt + down
 * 10.切换到下一行代码空位：shift + enter
 * 11.切换到上一行代码空位：ctrl + shift + enter
 * 12.如何查看源码：ctrl + 选中指定的结构   或  ctrl + shift + t
 * 13.退回到前一个编辑的页面：alt + left 
 * 14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right
 * 15.光标选中指定的类，查看继承树结构：ctrl + t
 * 16.复制代码： ctrl + c
 * 17.撤销： ctrl + z
 * 18.反撤销： ctrl + y
 * 19.剪切：ctrl + x 
 * 20.粘贴：ctrl + v
 * 21.保存： ctrl + s
 * 22.全选：ctrl + a
 * 23.格式化代码： ctrl + shift + f
 * 24.选中数行，整体往后移动：tab
 * 25.选中数行，整体往前移动：shift + tab
 * 26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o
 * 27.批量修改指定的变量名、方法名、类名等：alt + shift + r
 * 28.选中的结构的大小写的切换：变成大写： ctrl + shift + x
 * 29.选中的结构的大小写的切换：变成小写：ctrl + shift + y
 * 30.调出生成getter/setter/构造器等结构： alt + shift + s
 * 31.显示当前选择资源(工程 or 文件)的属性：alt + enter
 * 32.快速查找：参照选中的Word快速定位到下一个 ：ctrl + k
 * 33.关闭当前窗口：ctrl + w
 * 34.关闭所有的窗口：ctrl + shift + w
 * 35.查看指定的结构使用过的地方：ctrl + alt + g
 * 36.查找与替换：ctrl + f
 * 37.最大化当前的View：ctrl + m
 * 38.直接定位到当前行的首位：home
 * 39.直接定位到当前行的末位：end
```



## 第七章 异常处理

### 7.1 异常概述与异常体系结构

- java.lang.Throwable：所有异常、错误类的父类
  - java.lang.Exception：所有异常的父类
    - java.lang.RuntimeException：运行时异常
  - java.lang.Error：所有错误的父类

- Error（错误）：Java虚拟机无法解决的严重问题
  - StackOverflowError：栈空间溢出；
  - OOM：内存溢出。
- Exception（异常）：因编程错误或偶然因素导致的一般性问题
  - 编译时异常：编译器要求Java程序必须捕获或声明的异常。
  - 运行时异常（RuntimeException）：编译器不强制要求处理的异常，程序员可以不处理。



### 7.2 常见异常

- 常见的运行时异常

  ```java
  //NullPointerException
  //空指针异常
  	@Test
  	public void test2(){
  		int i = 10;
  		int j = 0;
  		System.out.println(i / j);
  	}
  //InputMismatchException
  //输入类型不匹配异常
  	@Test
  	public void test3(){
  		Scanner scann = new Scanner(System.in);
  		System.out.println("请输入一个整数：");
  		int num = scann.nextInt();
  		System.out.println(num);
  	}
  //ArrayIndexOutOfBoundsException
  //数组脚标越界异常
  	@Test
  	public void test4(){
  		int[] arr = new int[10];
  		System.out.println(arr[-9]);
  	}
  //StringIndexOutOfBoundsException
  //字符串角标越界异常
  	@Test
  	public void test5(){
  		String info = "hello";
  		System.out.println(info.charAt(-1));
  	}
  //ClassCastException
  //数据类型转换异常
  	@Test
  	public void test6(){
  		Object obj = new String("hello");
  		Date date = (Date)obj;
  	}
  //NumberFormatException
  //数据格式异常
  	@Test
  	public void test7(){
  		String str = "123";
  		str = "abc";
  		int num = Integer.parseInt(str);
  		System.out.println(num);
  	}
  ```

- 常见的编译时异常

  ```java
  //IOException
  //输入或输出异常
  //FileNotFoundException
  //找不到指定文件异常
  	@Test
  	public void test8(){
  //		File file = new File("hello.txt");
  //		FileInputStream fis = new FileInputStream(file);//FileNotFoundException
  //		int b = fis.read();//IOException
  //		while(b != -1){
  //			System.out.print((char)b);
  //			b = fis.read();//IOException
  //		}
  //		
  //		fis.close();//IOException
  	}
  	
  //ClassNotFoundException
  //找不到指定类异常
  	@Test
  	public void test9(){
  		//Class c = Class.forName("java.lang.String");//ClassNotFoundException
  	}
  ```



### 7.3 异常处理机制一：try-catch-finally

- 抓抛模型

  - Java程序执行过程中，若出现异常，系统会自动生成一个异常类对象，该对象会被提交给Java运行程序，这一过程称为抛出异常；
  - 异常对象的生成
    - 虚拟机根据异常类型自动生成对应类的异常对象；
    - 程序员手动创建异常类，再实例化异常对象。
  - 异常抛出后，会在此时代码所在方法内等待处理，若未处理，异常将继续抛给该方法的上层方法，直到被处理为止，这一过程称为捕获异常；
  - 若异常被抛到main()方法且main()方法也未处理，则程序运行终止。

- try-catch-finally语句

  - 使用格式

    ```java
    try{
    	...//可能出现异常的代码
    }catch(Exception1 e){
    	...//Exception1异常的处理方法
    }catch(Exception2 e){
    	...//Exception1异常的处理方法
    }finally{
    	...//一定会执行的语句
    }
    ```

  - try{}：编写可能出现异常的代码或抛出手动创建的异常，**一旦抛出异常，立即结束后续代码的执行，跳转到catch结构捕获对应异常类**；

  - catch(){}

    - catch结构是可选的；

    - ()中可接收形参类及形参类子类的对象（多态性）；

    - 若多个catch子句中接收的异常类之间存在子父类关系，必须将子类异常声明在前，否则编译不通过；

    - 常见的解决方法

      ```java
      //获取异常信息，返回字符串
      e.getMessage();
      //获取异常类名、异常信息及异常的出现位置，返回void
      e.printStackTrace();
      ```

  - finally{}

    - finally结构是可选的，**若定义了语句则必定会执行**；
    - **若try/catch/finally中同时定义了return语句返回值，try、catch中return语句的表达式会正常执行，但其返回值最后会被finally中的return返回值覆盖**；
    - 执行时间点
      1. try代码块未抛出异常，全部执行完后继续执行finally代码块；
      2. try代码块执行中抛出异常，catch结构捕获执行完处理语句或未捕获到时，继续执行finally代码块。



### 7.4 异常处理机制二：throws

- throws关键字的使用：将方法中可能出现的异常抛出，交给上层方法处理。

- 语法格式

  ```java
  public void readFile throws FileNotFoundException{
  	...
  }
  //支持多异常并列声明
  public void readFile throws FileNotFoundException, NotPointException{
  	...
  }
  ```

- throws用于重写方法时，**子类抛出的异常类型必须是父类异常类型的相同类或子类**（与方法重写中，返回值遵循的规则相同），若父类方法未抛出异常，则子类中只能使用try-catch结构。



### 7.5 手动抛出异常对象：throw

- 格式

  ```java
  public void regist(int id) throws Exception{
  	if(id > 0){
  		this.id = id;
  	}else{
  		//手动抛出一个异常类的对象
  		throw new RuntimeException("输入的id非法");
  		throw new Exception("输入的id非法");
  	}
  }
  ```

- **throw与throws的区别**

  - 第一步：生成异常类对象
    - 自动生成；
    - throw手动生成。
  - 第二步：异常处理
    - try-catch-finally捕获异常；
    - throws抛给上层方法。



### 7.6 用户自定义异常类

- 自定义异常类的过程	

  1. 继承于现有的异常类
  2. 提供一个序列版本号
  3. 提供重载的构造器

  ```java
  public class MyException extends Exception{//继承于现有的异常类
  	
  	static final long serialVersionUID = -19950206L;//提供一个任意long型序列版本号
  	
  	public MyException(){}
  	
  	public MyException(String message){//提供重载的构造器
  		super(message);
  	}
  }
  ```

  ```java
  try{
  	throw new MyException("出现异常");//抛出自定义异常对象
  }catch(MyException e){
  	e.getMessage;//打印“出现异常”
  }
  ```




## 第八章 枚举类与注解

### 8.1 枚举类

- 枚举类：类的对象的是确定的，数量是有限的；
- 当定义一组常量时，可使用枚举类定义，枚举类可实现只有一个对象的单例模式。
- **枚举类中的常量，既是类的属性（声明为枚举类类型的全局常量），也是类的对象（调用枚举类自身的私有构造器创建）**。



#### 8.1.1 自定义枚举类

```java
class Season{
	
	//1. 声明每个对象拥有的属性，private final修饰
	private final String SEASON_NAME;
	private final String SEASON_DESC;
	
	//2. 私有化类的构造器
	private Season(String seasonName,String seasonDesc){
		this.SEASON_NAME = seasonName;
		this.SEASON_DESC = seasonDesc;
	}
	
	//3. 创建枚举类中的对象(全局常量) ，public static final修饰
	public static final Season SPRING = new Season("春天","春暖花开");
	public static final Season SUMMER = new Season("夏天","夏日炎炎");
	public static final Season AUTUMN = new Season("秋天","秋高气爽");
	public static final Season WINTER = new Season("冬天","白雪皑皑");
	
	//4. 提供toString()方法
	@Override
	public String toString() {
		return "Season [SEASON_NAME=" + SEASON_NAME + ", SEASON_DESC=" + SEASON_DESC + "]";
	}

	public String getSEASON_NAME() {
		return SEASON_NAME;
	}

	public String getSEASON_DESC() {
		return SEASON_DESC;
	}
	
	
}
```



#### 8.1.2 使用enum关键字定义枚举类

- enum定义的枚举类默认继承了java.lang.Enum类，因此**不能再使用extends**关键字继承其他类；
- **枚举类的构造器必须使用private修饰**；
- **必须在枚举类第一行声明枚举类对象**。

```java
enum Season{
    
	//1. 创建枚举类中的对象,必须声明在enum枚举类的首位,使用","连接每个对象，使用"；"结束创建
    //等价于public static final Season SPRING = new Season("春天","春暖花开");
    //不同于接口可选的省略修饰符，枚举类中定义的全局常量必须省略修饰符、构造器，只保留常量名与构造器传参
	SPRING("春天","春暖花开"),
	SUMMER("夏天","夏日炎炎"),
	AUTUMN("秋天","秋高气爽"),
	WINTER("冬天","白雪皑皑");
	
	//2. 声明每个对象拥有的属性:private final修饰
	private final String SEASON_NAME;
	private final String SEASON_DESC;
	
	//3. 私有化类的构造器
	private Season1(String seasonName,String seasonDesc){
		this.SEASON_NAME = seasonName;
		this.SEASON_DESC = seasonDesc;
	}

	public String getSEASON_NAME() {
		return SEASON_NAME;
	}

	public String getSEASON_DESC() {
		return SEASON_DESC;
	}

}
```



#### 8.1.3 enum类的主要方法

- toString()

  ```java
  //返回当前枚举类对象的对象名
  String s = Seanson.SPRING.toString();
  System.out.println(s);//输出“SPRING”
  ```

- values()

  ```java
  //返回所有枚举类对象组成的数组
  Season[] s = Season.values();
  //遍历枚举类对象
  for(int i = 0; i < s.length; i++){
      System.out.println(s);
  }
  ```

- valuesOf(String name)

  ```java
  //返回指定名称的枚举类对象,注意区分大小写，形参必须为全大写（常量定义规范）
  Season s = Season.valuesOf("SPRING");
  ```

  

#### 8.1.4 实现接口的枚举类

- 和普通Java类一样，枚举类可以实现一个或多个接口；

- 若每个枚举值实现接口的方法（重写方法）相同，则在枚举类中只重写一次该方法即可；

- 若每个枚举值实现接口的方法不同，则通过匿名对象的方式对接口方法分别重写。（枚举类中无需再重写）

  ```java
  SPRING("春天","春暖花开"){public void show(){System.out.println("春")}},
  SUMMER("夏天","夏日炎炎"){public void show(){System.out.println("夏")}},
  AUTUMN("秋天","秋高气爽"){public void show(){System.out.println("秋")}},
  WINTER("冬天","白雪皑皑"){public void show(){System.out.println("冬")}};
  ```

  

### 8.2 注解（Annotation）

#### 8.2.1 注解概述

- Annotation是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。使用Annotation可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。



#### 8.2.2 常见注解

- 文档注解

| 注解       | 说明                   |
| ---------- | ---------------------- |
| @author    | 表名开发该类模块的作者 |
| @version   | 表名该类模块的版本     |
| @see       | 参考见相关主题         |
| @since     | 模块开发时的版本       |
| @param     | 方法形参的说明         |
| @return    | 方法返回值的说明       |
| @exception | 方法抛出异常的说明     |

- 编译时进行格式检查

| 注解              | 说明                     |
| ----------------- | ------------------------ |
| @Override         | 限定方法为重写方法       |
| @Deprecated       | 表示琐修饰的元素已经过时 |
| @SuppressWarnings | 抑制编译器的警告         |



#### 8.2.3 自定义注解

- 注解使用关键字@Interface定义；

- 注解默认继承了java.lang.annotation.Annotation接口；

- 注解的成员变量以**无参方法**的方式声明，方法的方法名和返回值对应该成员的名字和数据类型，称为配置参数。数据类型包括8种基本数据类型、String、Class、enum、Annotation及以上数据类型的数组；

  ```java
  String value();
  ```

- 成员变量可以使用default声明默认值。

  ```java
  String value() default "haha";
  ```



#### 8.2.4 元注解

- 元注解（meta-annotation）：用于修饰注解的注解；
- 4个标准的元注解
  - Retention：指定注解的生命周期
    - Retention(RetentionPolicy.SOURSE)：源文件中有效，编译器丢弃；
    - Retention(RetentionPolicy.CLASS)：class文件中有效，JVM不保留；
    - Retention(RetentionPolicy.RUNTIME)：运行时有效，JVM保留，程序可通过反射获取注释。
  - Target：指定注解可用于修饰哪些元素
    - 可选择修饰的元素包括：CONSTRUCTOR(构造器)、FIELD(域)、LOCAL_VARIABLE(局部变量)、METHOD(方法)、PACKAGE(包)、PARAMETER(参数)、TYPE(类、接口、枚举类)
  - Documented：指定注解将被javadoc工具提取成文档；
  - Inherited：指定注解将具有继承性，该注解修饰的类的子类也被该注解修饰。



#### 8.2.5 通过反射获取注解信息



#### 8.2.6 JDK8中的新特性

- 重复注解

  ```java
  //JDK7前
  @MyAnnotations({@MyAnnotation,@MyAnnotation(value="abc")})
  //JDK8后
  @MyAnnotation(value="abc")
  @MyAnnotation
  class Person{
  }
  ```

- Target可修饰元素扩充

  - TYPE_PARAMETER
  - TYPE_USE



## 第九章 多线程

### 9.1 程序 进程 线程

- 程序（Program）：为完成特定任务，用编程语言编写的一组指令的集合；
- 进程（Process）：程序的一次执行过程，或正在运行的一个程序；
- 线程（Thread）：进程的进一步细化，一个程序内部的一条执行路径。
- 进程与线程
  - 进程是资源分配的单位，系统在程序运行时，为该进程分配一定的内存区域；
  - 线程是调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销；
  - 一个进程中的**多个线程共享堆和方法区**，**独立拥有虚拟机栈、本地方法栈、程序计数器**。
    - 优点：便于一个进程中的多个线程共享数据，方便线程间通信；
    - 缺点：多个线程共享的系统资源可能带来安全隐患。
- 并行与并发
  - 并行：多个CPU同时执行多个任务；
  - 并发：一个CPU同时执行多个任务。



### 9.2 线程的创建和使用

- Java语言的JVM允许程序运行多个线程，通过java.lang.Thread类实现；

- 创建线程的两种方式

  - **继承Thread类**

    ```java
    //1、定义Thread类的子类
    public class SubThread extends Thread {	
    	//2、重写Thread类中的run()方法
    	@Override
    	public void run(){
    		System.out.println("hhh");
    	}
    }
    
    public class Test{
    	public static void main(){		
    		//3、创建线程对象
    		SubThread s = new SubThread();		
    		//4、调用线程对象的start()方法
    		s.start();
    	}
    }
    ```

    - 要启动多线程，必须调用start()方法；
    - 一个线程对象只能调用一次start()方法，重复调用将抛出异常
    - IllegalThreadStateException。

  - **实现Runnable接口**

    ```java
    //1、定义Runnable接口的实现类
    public class SubThread implements Runnable {	
    	//2、重写Runnable接口中的run()方法
    	@Override
    	public void run(){
    		System.out.println("hhh");
    	}
    }
    
    public class Test{
    	public static void main(){      
    		//3、将Runnable实现类的对象作为形参通过Thread类的带参构造器创建线程对象
    		Thread t = new Thread(new SubThread());		
    		//4、调用线程对象的start()方法
    		t.start();
    	}
    }
    ```

  - 两种方式区别

    - 继承Thread：线程代码存放在Thread子类的 run()方法中；
    - 实现Runnable：线程代码存放在Runnable实现类的run()方法中。

  - 实现类的好处：避免了单继承的局限性，多个线程可以共享同一个接口实现类的对象，适合多个线程处理同一份资源；

  - **Thread类本身也是Runnable接口的实现类**。

- Thread类的构造器

  | 构造器                               | 说明                             |
  | ------------------------------------ | -------------------------------- |
  | Thread()                             | 空参                             |
  | Thread(String thread name)           | 形参为线程名                     |
  | Thread(Runnable target)              | 形参为Runnable实现类对象         |
  | Thread(Runnable target, String name) | 形参为Runnable实现类对象、线程名 |

- Thread类的常用方法

  | 方法                   | 说明                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | start()                | 启动线程，调用run()方法                                      |
  | run()                  | 方法中声明线程要执行的操作                                   |
  | currentThread()        | 获取执行当前代码的线程，返回Thread                           |
  | getName()              | 获取当前线程名，返回String                                   |
  | setName()              | 设置当前线程名                                               |
  | sleep(long milisecond) | 阻塞当前线程（毫秒）                                         |
  | yield()                | 释放当前线程的cpu执行权                                      |
  | join()                 | 阻塞当前线程，待调用该方法的线程执行结束后再继续执行当前线程 |
  | isAlive()              | 判断当前线程是否存活，返回boolean                            |

- 线程的优先级

  - 线程的优先等级
    - MAX_PRIORITY：10；
    - MIN_PRIORITY：1；
    - NORM_PRIORITY：5；
  - 相关方法
    - getPriority()：返回线程优先值，int型；
    - setPriority(int i)：设置线程优先值，只能设置1-10，否则编译不通过。
  - **线程创建时继承父类的优先级**，优先级只影响cpu优先执行的概率，并不绝对决定先后。



### 9.3 线程的声明周期

![image-20200310200744836](java上.assets/image-20200310200744836.png)

- Thread内部定义了线程声明周期的内部枚举类State
  - NEW：新建
  - RUNNABLE：就绪、运行
  - BLOCKED：阻塞
  - WAITING：阻塞
  - TIMED_WAITING：阻塞
  - TERMINATED：死亡



### 9.4 线程的同步

- Java中通过使用线程同步机制，解决线程的安全问题。

#### 9.4.1 同步代码块

- 格式

  ```java
  synchronized(同步监视器){
  	需要同步的代码；
  }
  ```

- 任何对象都可以作为同步监视器（同步锁），因为他们都自动含有单一的同步监视器；

- **要实现同步的多个线程必须指向同一个同步监视器**；

- 一般可直接使用"this"或"类名.class"充当同步锁。

#### 9.4.2 同步方法

- 格式

  ```java
  public synchronized void method(){}//默认监视器为this
  
  public static synchronized void method(){}//默认监视器为类名.class
  ```

- 同步方法不需要显式声明监视器，但都设置了默认的监视器。



释放锁的操作

1. 当前线程的同步方法、同步代码块执行结束；
2. 当前线程的同步方法、同步代码块中的break、return语句终止线程的执行；
3. 当前线程在运行过程中抛出了未处理的Error或Exception；
4. 当前线程执行到了同步锁的wait()方法。



#### 9.4.3 懒汉式（线程安全）

```java
public class Lazz{
    
	private Lazz(){}
	
	private static Lazz lazz = null;
	
	public static Lazz getInstance(){
		if (lazz = null) {
			synchronized (Lazz.class) {
				if (lazz == null){
					lazz = new Lazz();
				}
			}
		}
		return lazz;
	}
    
}
```



#### 9.4.4 线程的死锁

- 不同的线程分别占用对方需要同步的资源不放弃，都在等待对方放弃自己需要的资源，就形成了线程的死锁；
- 解决方式
  - 编写专门的算法、原则；
  - 减少同步资源的定义；
  - 避免嵌套同步。



#### 9.4.5 Lock(锁)

- java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。

- ReentrantLock类是Lock接口的实现类，拥有和synchronized相同的语义。

- 使用方法

  ```java
  Class Test {
  	//实例化ReentrantLock类的对象
  	private ReentrantLock lock = new ReentrantLock();
  	
  	public void run(){
  		//调用对象的lock()方法对代码加锁
  		lock.lock();
  		try {
  			//加锁的代码块
  		} finally {
  			//调用对象的unlock方法解锁，必须执行！
  			lock.unlock();
  		}
  	}
  }
  ```

- synchronized与Lock的对比

  - Lock是显式锁（手动开启关闭），synchronized是隐式锁（出作用域自动释放）；
  - Lock只能对代码块使用，synchronized可用于代码块和方法；
  - Lock锁性能更好，可减少JVM调度线程的时间，且更具扩展性。



### 9.5 线程的通信

- Object类中的三个方法；
  - wait()：挂起当前线程，释放对象的监控权，然后线程进入等待状态，当其他线程调用notify()方法后被唤醒，继续从挂起处向下执行；
  - notify()：唤醒当前排队等待的线程中优先级最高的线程；
  - notifyAll()：唤醒当前排队等待的所有线程。
- 三个方法只能在synchronized方法或synchronized代码块中使用，否则抛出IllegalMonitorStateException；
- **三个方法的调用者必须和想要配合使用的synchronized同步锁对象一致，使用的前提条件都是必须具有调用对象的监控权**；
- wait()与sleep()对比
  - wait()是定义在Object类中的成员方法，sleep()是定义在Thread类中的静态方法；
  - wait()调用时释放当前同步对象的同步锁，sleep()使所在线程休眠，与同步锁无关；
  - wait()只能用于synchronized结构中，sleep()可以用于线程的任何位置；
  - wait()需要被notifu()方法唤醒，sleep()在设置时间结束后自动唤醒。



### 9.6 JDK5.0新增线程创建方式

#### 9.6.1 方式一：实现Callable接口

- 与Runnable接口相比，Callable接口功能更强大

  - 方法可以有返回值；
  - 方法可以抛出异常；
  - 支持泛型的返回值；
  - 需要借助FutureTask类使用相关功能，比如获取返回值。

- Future接口

  - 可以对Runnable/Callable任务的执行结果进行取消、查询是否完成、获取结果等；
  - **FutrueTask是Future接口的唯一的实现类**；
  - **FutureTask同时实现了Runnable，Future接口**，因此可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。

- 使用步骤：计算1-100的整数和

  ```java
  //1.定义Callable的实现类
  class Sum implements Callable{
  	//2.重写Callable接口中的call()方法
  	@Override
  	public Object call() throws Exception {	
  		int sum = 0;
  		for (int i = 1; i <= 100; i++) {
  			sum += i;
  		}
  		return sum;
  	}
  }
  
  public class SumTest{
  	public static void main(String[] args) {	
         	//3.创建Callable接口实现类的对象
  		Sum sum = new Sum();
  		//4.将对象作为形参创建FutureTask类的对象
          FutureTask future = new FutureTask(sum);
  		//5.将FutureTask类对象作为形参新建线程并启动
  		new Thread(future).start();
  		//6.调用FutureTask类对象的get()方法，获得call()方法的返回值
  		try {
  			System.out.println(future.get());
  		} catch (InterruptedException e) {
  			e.printStackTrace();
  		} catch (ExecutionException e) {
  			e.printStackTrace();
  		}
  	}
  }
  ```

  

#### 9.6.2 使用线程池

- 概念：提前创建好多个线程放入线程池中，使用时直接获取，使用完后放回线程池中。可以避免线程的频繁创建销毁，实现重复利用。
- 线程池的优点
  - 提高响应速度
  - 降低资源消耗
  - 便于线程管理



